/**
 * Generates the deck.gl layers interface for R
 * All layer functions are written to ./R/deckgl-layers.R
 */

const fs = require("fs/promises");
const path = require("path");
const util = require("util");
const exec = util.promisify(require("child_process").exec);
const ejs = require("ejs");
const deck = require("deck.gl");
const { snakeCase } = require("snake-case");

/* exclude props from function signatures */
const excludeProps = [
  /* layer */
  "coordinateOrigin",
  "coordinateSystem",
  "dataComparator",
  "dataTransform",
  "extensions",
  "fetch",
  "getPolygonOffset",
  "highlightedObjectIndex",
  "modelMatrix",
  "parameters",
  "uniforms",
  "updateTriggers",
  "wrapLongitude",
  /* composite layer */
  "renderSubLayers",
  /* text layer */
  "characterSet",
  /* tile 3d layer */
  // "loader"
];

function rgba2hex(rgba) {
  const hex = (x) => ("0" + (x & 0xff).toString(16)).slice(-2);
  return "#" + rgba.map(hex).join("");
}

function quoteName(key) {
  return /^\.*[^.a-z]/i.test(key) || /[^.\w]/i.test(key) ? JSON.stringify(key) : key;
}

/**
 * @typedef {Object} PropType
 * @property {string} name
 * @property {string} type
 * @property {any} value
 * @param {PropType} prop
 */
function defaultValue({ name, type, value }) {
  if (name.endsWith("Color") && Array.isArray(value)) {
    return format(rgba2hex(value));
  }

  if (name === "colorRange" && Array.isArray(value)) {
    return format(value.map(rgba2hex));
  }

  if (type === "accessor" && typeof value === "function") {
    const [match] = /(?<=return\s+).*(?=;)/.exec(value.toString());
    return snakeCase(match.split(".").pop());
  }

  return format(value);

  function format(value) {
    if (value == null) {
      return null;
    }

    if (Array.isArray(value)) {
      return value.length === 0 ? null : `c(${value.map(format).join(", ")})`;
    }

    switch (typeof value) {
      case "boolean":
        return String(value).toUpperCase();
      case "number":
        return value;
      case "string":
        return JSON.stringify(value);
      case "object": {
        const entries = Object.entries(value);
        /* escape name */
        if (entries.length === 0) {
          return null;
        }
        const sep = entries.length > 1 ? ",\n" : ", ";
        const items = entries.map(([k, v]) => quoteName(k) + " = " + format(v)).join(sep);
        return `list(${items})`;
      }
      default:
        return null;
    }
  }
}

/**
 * @param {deck.Layer} Layer
 */
function templateData(Layer) {
  // initialise _propTypes
  new Layer();

  // remove polygon from geo-layers
  if (/^S2|H3/.test(Layer.layerName)) {
    // we don't need this
    delete Layer._propTypes.getPolygon;
  }

  // default text layer font
  if (Layer === deck.TextLayer) {
    Layer._propTypes.fontFamily.value = "Roboto, san-serif";
    Layer._propTypes.fontSettings.value = { sdf: true };
  }

  return {
    name: snakeCase(Layer.layerName)
      // GeoJsonLayer -> geojson_layer
      .replace("geo_json", "geojson")
      // Tile3DLayer -> tile3d_layer
      .replace("3_d", "3d"),
    type: Layer.layerName,
    props: Object.values(Layer._propTypes)
      .filter((propType) => !excludeProps.includes(propType.name))
      .filter((propType) => !/^(_|on)/.test(propType.name))
      .map((propType) => ({
        ...propType,
        name: snakeCase(propType.name),
        value: defaultValue(propType),
      })),
  };
}

const layers = Object.values(deck)
  .filter((x) => x.prototype instanceof deck.Layer && x !== deck.CompositeLayer)
  .map(templateData);

const template = path.join(__dirname, "layer.ejs").replace(/\\/g, "/");
const output = path.join(__dirname, "../R/deckgl-layers.R").replace(/\\/g, "/");
const generatedBy = `
  # Generated by rdeck: do not edit by hand
  # deck.gl version: ${deck.Deck.VERSION}
`;

Promise.all(layers.map((layer) => ejs.renderFile(template, layer, { rmWhitespace: true })))
  .then((layers) => {
    const content = [generatedBy, ...layers].join("\n\n");
    return fs.writeFile(output, content);
  })
  .then(() => exec(`Rscript -e "styler::style_file('${output}')"`));
